(ns project-euler.problem_0044)

;; Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2.
;; The first ten pentagonal numbers are:

;; 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

;; It can be seen that P4 + P7 = 22 + 70 = 92 = P8.
;; However, their difference, 70 − 22 = 48, is not pentagonal.

;; Find the pair of pentagonal numbers, Pj and Pk,
;; for which their sum and difference are pentagonal and
;; D = |Pk − Pj| is minimised; what is the value of D?

(defn seq-pentagonals
  []
  (->> (iterate inc 1)
       (map (fn [n] (/ (* n (- (* 3 n) 1)) 2)))
       ))

(defn search-in-ordered-seq [x ys]
  (loop [[y & yys] ys]
    (cond (= x y) yys
          (< x y) nil
          :else (recur yys))))

(defn solution1 []
  (loop [[d & seq-next-d] (seq-pentagonals)]
    (let [jk (loop [[j & seq-next-j] seq-next-d]
               (let [k (+ d j)
                     ks (search-in-ordered-seq k seq-next-j)]
                 (cond (and  ks (search-in-ordered-seq (+ k j) ks)) [j k]
                       (< (- (first seq-next-j) j) d) (recur seq-next-j)
                       :else false
                       )
                 ))]
      (if jk 
        jk
        (recur seq-next-d)))
    )
  )

(defn solution2 []
  (loop [[d & seq-next-d] (seq-pentagonals)]
    (let [jk (loop [[j & seq-next-j] seq-next-d]
               (let [k (+ d j)
                     ks (search-in-ordered-seq k seq-next-j)]
                 (cond ks (do (println d j k)
                              (cond (search-in-ordered-seq (+ k j) ks) [j k]
                                    (<= (- (first seq-next-j) j) d) (recur seq-next-j)
                                    :else false
                                    ))
                       (<= (- (first seq-next-j) j) d) (recur seq-next-j)
                       :else false
                       )
                 ))]
      (if jk 
        jk
        (recur seq-next-d)))
    )
  )

(defn pentagonal [n] (/ (* n (- (* 3 n) 1)) 2))

(defn is-pentagonal? [p]
  (let [delta (+ 0.25 (* 6 p))
        x (int (+ 0.5 (/ (+ 0.5 (Math/sqrt delta)) 3)))]
    (== p (pentagonal x))
    ))

(defn solution4 []
  (->> (iterate inc 1)
       (map (fn [nd] [nd (pentagonal nd)]))
       (map (fn [[nd d]] (do (println d) [nd d])))
       (mapcat (fn [[nd d]]
                 (->> (iterate inc nd)
                      (map (fn [nj]
                             (let [j (pentagonal nj)
                                   dj (- (pentagonal (inc nj)) j)]
                               [j dj])))
                      (take-while (fn [[j dj]] (<= dj d)))
                      (map (fn [[j dj]] [d j]))
                               )))
       (filter (fn [[d j]] (and (is-pentagonal? (+ j d))
                                (is-pentagonal? (+ j j d)))))
       (first)
       ))

(defn solution []
  (loop [i 1, s (sorted-set)]
    (let [a+b (pentagonal i)]
      (or (some (fn [a] (let [b (- a+b a)] (and (s b) (s (- b a)))))
                s)
          (recur (inc i) (conj s a+b))))
    ))
